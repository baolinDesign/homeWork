1,
答案:10 因为此时i是全局作用域下面的i，在循环执行完成后，i已经被累加到10了，无论是执行第几个，都会是10，如果把var 换成let，就会产生块级作用域，就会相应打出0~9，还可以使用闭包来解决
<br>

2,
答案: 报错：ReferenceError
原因: 块级作用域,console.log只会在if里面执行，然后因为let在变量声明之前就访问变量的话，会直接提示 ReferenceError，如果是var在后面 则返回undefined
<br>

3,
答案:
```
let minVal = (val)=>Math.min(...val)
minVal(arr)
或者
consolelog（Math.min(...arr))
```
<br>

4,
答案:
a),var声明的变量存在变量提升，let和const不存在变量提升
b),let const 声明的变量存在块块级作用域，而var 没有，同时，const相比于let，它声明时必须赋值，且赋值后不能修改,它如果声明的是复合类型数据，可以修改其属性
c),同一作用域下let和const不能声明同名变量
<br>

5,
答案:
undefined，因为setTimeout是一个箭头函数，所以这个this是继承上一个函数的执行上下文，而他的上一个函数是fn，里面没有a属性，所以是undefined，
<br>

6,
答案:
因为在es5中，对象属性名都是字符串，容易造成属性名冲突 通过symbol('')创建的值是唯一的,用Symbol来表示独一无二的值,最主要的作用就是为对象添加独一无二的属性名
<br>

7,
答案：
浅拷贝：对内存地址的复制，让目标对象指针和源对象指向同一片内存空间

深拷贝：深拷贝是指，拷贝对象的具体内容，二内存地址是自主分配的，拷贝结束之后俩个对象虽然存的值是一样的，但是内存地址不一样，俩个对象页互相不影响，互不干涉

8，
答案：
##我的理解：(js异步编程)
js是单线程的，在某个时间只能做某件事情，同一时间只能做一件事情，为了解决这个问题，提出了 '异步编程':
首先是：callback --结果出现了回掉地狱，为了解决这个问题，就出现了promise，用了一段时间后，发现解决的不彻底，还是在then中使用了回调函数，然后提出了终极解决办法async / await
##event loop:
js中，所有同步任务都在主线程上执行，也可以理解为存在一个“执行栈”,
主线程外，还有一个“任务队列”，任务队列的作用，就在等待异步任务的结果，只要异步任务有了运行结果，就会加入到“任务队列”中。一旦执行栈中所有同步任务执行完毕，就从 任务队列 中读取“任务”加入到“执行栈”中。
然后就不断重复上面的操作，直到所有任务完成
##宏任务和微任务
简单说就是大任务和小任务；比如:去银行办业务，要取号排号，因为柜员同时只能处理一个来办理业务的客户，这时每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的，当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。
但是，在宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，办存款过程中，可以查余额，转账之类的，所以本来快轮到你来办理业务，会临时添加的“业务”而往后推,
无论是什么需求，只要是柜员能够办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。所以,在当前的微任务没有执行完成时，是不会执行下一个宏任务的。


<br>
9,答案（如下代码）
```
function setout (val) {
  return new Promise(function(resolve,reject){
    setTimeout(function(){
      resolve(val)
    },10)
  })
}
var aa = Promise.all([
  setout('hello'),
  setout('lagou'),
  setout('I love YOU')
])
aa.then(function(values){
  console.log(values)
  let [a,b,c]=values
  console.log(a+b+c)
}).catch(function(err){
  console.log(err)
})
```
<br>

10,
答案：
TypeScript是Javascript的超集或扩展集,在javascript基础上多了一些扩展,当然最后代码还是编译为Javascript,typescript相对于ES6,TypeScript最大的改善是增加了类型系统。
ES6是Javascript语言的标准，typescript是ES6的超集.

11,
答案：
优点：1，功能强大，生态很健全、完善;
    2,在写js中，可以避免类型错误,提前检测出可能出现的bug
    3，渐进式的，即使什么也不知道，也可以按js标准语法来写
缺点：1，语言本身多了很多还念，提高了学习成本
    2，周期比较短的项目,TypeScript会增加开发成本

